from datetime import datetime, time, timedelta
from pandas.io.data import DataReader
from pandas.io.data import Options

import datetime as dt
import matplotlib.pyplot as plt
import scipy.stats as ss
import time
import numpy as np
import pdb
import csv


def jgb_3graphs():
	""""
	This function calculates the open, close and daily VWAP prices for all the days in
	the JB2014_JST.csv file and graphs the result.

	return: a tuple of lists where the first element is the open prices, second
	is the close prices and the third is vwap prices.

	NOTE: Please do not have the file anywhere other than your current working 
	directory when reading the csv file such that when opening it should be you should only 
	have to call something like open('JB2014_JST.csv') and NOT 
	open('/foldname1/foldname2/user/JB2014_JST.csv'))

	NOTE2: This function may take awhile to run depending on how you implement
	"""
	f = open('JB_2014_JST.csv', 'rU')
	csv_f = csv.reader(f)

	price=[]
	size=[]
	#open_price=[]
	#close_price=[]
	#vwap=[]
	result=[]
	#temp_result=[]
	for row in csv_f:
		date=datetime.strptime(row[1]+' '+row[2],'%m/%d/%Y %I:%M:%S %p')
		#pdb.set_trace()
		
		if time(8, 45) <= date.time() <= time(15,02):
			#if current price is within trading hours
			if not price: #price is empty take care of initial case
				initial_day = date.day
			else:
				if date.day != initial_day:
					# compute open, end, vwap
					# and empty price+size lists, then
					# append price+size for new "day"
					#temp_result.append(price[0])
					#temp_result.append(price[-1]) #last element
					prices=np.array(price,dtype=float)
					sizes=np.array(size,dtype=float)
					#pdb.set_trace()
					result.append([price[0],price[-1],np.dot(prices,sizes)/sum(sizes)])
					del price[:]
					del size[:]
					initial_day = date.day

			price.append(row[3])
			size.append(row[4])

	#pdb.set_trace()
	# x = np.arange(len(open_price)) + 1 
	# plt.plot(x, np.array(open_price), 'r--', x, np.array(close_price),'bs', x, np.array(vwap),'g^')
	# plt.show()
	return result

def dayEffect(t1,t2,S,d):
	"""
	param t1: the start date in the format 'yyyy-MM-dd'
	param t2: the end date in the format 'yyyy-MM-dd'
	param S: the stock symbol as can be found on yahoo finance
	param d: the day of the week to preform the backtesting where
	 	0=Monday, 1=Tuesday, ... 4=Friday (5 and 6 are weekends and do not trade)
	 	(notice this is different from what the pdf states)

	return: profit genereated from the trading strategy

	Function calculates the profit generated from buying a stock at open everyday
	between t1 and t2 (inclusive) and sells on the close for day d. Profit generated from such
	a strategy is returned.

	NOTE: please have the day which is the most profitable listed as a comment at the END 
	of this function
	"""
	bars = DataReader(S, "yahoo", datetime.strptime(t1, '%Y/%m/%d'),datetime.strptime(t2,'%Y/%m/%d'))
	#pdb.set_trace()
	
	#returns=[]
	profit=0
	for i in range(len(bars.index)):
		pdb.set_trace()
		print 'check if bars.index[i].day returns d or d+1'
		if bars.index[i].day == (d+1):
			profit += bars['Close'][i]-bars['Open'][i]
			#returns.append((bars['Close'][i]-bars['Open'][i])/bars['Open'][i])

	#print 'The average return for the startegy is ' + str(np.mean(returns)) + ' when trading on every ' + str(d) + ' day'
	print 'The profit generated by buying/selling one share on every day is ' + str(profit)
	# By running dayEffect 5 times for Mon - Friday, the day that is most profitable is 

#Black and Scholes
def d1(S0, K, r, sigma, T):
	return (np.log(S0/K) + (r + sigma**2 / 2) * T)/(sigma * np.sqrt(T))
 
def d2(S0, K, r, sigma, T):
	return (np.log(S0 / K) + (r - sigma**2 / 2) * T) / (sigma * np.sqrt(T))
 
def BlackScholes(type,S0, K, r, sigma, T):
	if type=="C":
		return S0 * ss.norm.cdf(d1(S0, K, r, sigma, T)) - K * np.exp(-r * T) * ss.norm.cdf(d2(S0, K, r, sigma, T))
	else:
		return K * np.exp(-r * T) * ss.norm.cdf(-d2(S0, K, r, sigma, T)) - S0 * ss.norm.cdf(-d1(S0, K, r, sigma, T))

def impliedVolBisection(S,K,T,r,Price,x1,x2,Call=True,d=0,tol=0.0001):
	"""
	param S: the stock price
    param K: the strike price
    param r: the risk free rate
    param T: time to mature of the option (percent of year in decmial form)
    param Price: The price of the option you are trying to find implied vol for
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations
    
    returns: implied vol with above paramaters

    Finds the implied volatility using the above paramters for a option using the 
    bisection method
	"""
	#tol = 0.000001
	a=x1
	b=x2

	def f(x):
		return BlackScholes('C',S,K,r,x,T) - Price

	c = (a+b)/2.0
	while (b-a)/2.0 > tol:
		if f(c) == 0:
			return c
		elif f(a)*f(c) < 0:
			b = c
		else :
			a = c
		c = (a+b)/2.0
		
	return c

def impliedVolNewton(S,K,T,r,Price,x0,Call=True,d=0,tol=0.0001):
	"""
	param S: the stock price
    param K: the strike price
    param r: the risk free rate
    param T: time to mature of the option (percent of year in decmial form)
    param Price: The price of the option you are trying to find implied vol for
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations
    returns: implied vol with above paramaters

    Finds the implied volatility using the above paramters for a option using 
    newton's method
    """
    def f(x):
		return BlackScholes('C',S,K,r,x,T) - Price

	def df(x,dx):
		return (f(x+dx) - f(x))/dx

	x=x0
	dx=tol
	#tol=0.000001

	while True:
		x1 = x - f(x)/df(x, dx)
		t = abs(x1 - x)
		if t < tol:
			break
		x = x1

	return x

# def getOptionsData(ticker, expiryDate):
# 	data = Options(ticker, 'yahoo')
# 	opt_data = data.get_call_data(expiry=expiryDate)
# 	return opt_data

def QuadFit(symbol,strikes,expiry_date,r,Call=True,d=0,tol=.0001):
	"""
	param symbol: stock symbol
	param strikes: list of strikes in increasing order
	param expiry_date: expiry date in format 'yyyy-MM-dd'
	param r: risk free rate
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations

	This function fits a quadratic function to the strikes given and graphs 
	the quadratic function and implied vols on the same graph

	returns: nothing

	NOTE: This function may take awhile to run depending on how you implement.
	In addition please use 365 days when calculating T and live prices (20 minute delay is OK).
	See the module yahoo_finance's Share class for a simply way to do this.
	"""
	tic=time.clock()
	#data = Options(ticker, 'yahoo')
	data = Options(symbol, 'yahoo').get_call_data(expiry=expiryDate)
	#data = getOptionsData(symbol, dt.date(2015,12,1))
	bars = DataReader(symbol, 'yahoo', datetime.today() - timedelta(hours=24), datetime.today())
	toc=time.clock()
	print 'Took ' + str(toc-tic) + ' seconds to load data using pandas'
	
	pdb.set_trace()

	S = float(bars['Close'])
	T = (365 - float(datetime.today().day))/365

	#pdb.set_trace()

	#strikes=[]
	impVols=[]
	#num_strikes = data.shape[0]
	tic=time.clock()
	for i in range(len(strikes)):
		K = strikes[i] #data.index[i][0]
		C = data.iloc[i][0]
		#strikes.append(K)
		impVols.append(impliedVolBisection(S,K,T,r,C,0,1))
		#pdb.set_trace()

	toc=time.clock()
	print 'Took ' + str(toc-tic) + ' seconds to complete all IV calculations'
	x=np.array(strikes)
	y=np.array(impVols)
	z = np.polyfit(x, y,2) #fit a second order polynomial to IV
	p = np.poly1d(z)

	#pdb.set_trace()

	xp = np.linspace(strikes[0], strikes[-1], num_strikes)
	plt.plot(x, y, '.', xp, p(xp), '-')
	plt.ylim(0.1,0.6)
	plt.show()

if __name__ == '__main__':

	S0 = 100.0 #stock price
	K = 110.0 #strike price
	T = 3.0 #Years
	r = 0.1 #rf rate (decimal)
	c_Price = 37.0 #call price
	x1 = 0.1 #a or x1 for bisection method 
	x2 = 0.5 #b or x2 for bisection method 
	x0 = 0.4 #initial guess for newton's method 
	symbol = 'SPY' #symbol for option
	day = -1  #day for dayEffect 0=Monday 1= Tuesday ... 4= Friday
	strikes = [150,160,170,180,190,195,200,210,220,230] #list of strike prices
	expiry_date = '2015-12-19' #expiry date for option

	#Preform Question 1 Hw1
	jgb_3graphs()

	#Preform Question 2 Hw1
	dayEffect('2014-01-01','2014-12-31',symbol,day)
	
	#Preform Question 3 Hw1
	impliedVolBisection(S0,K,T,r,c_Price,x1,x2)

	#Preform Question 4 Hw1
	impliedVolNewton(S0,K,T,r,c_Price,x0)

	#Preform Question 5 Hw1
	QuadFit(symbol,strikes,expiry_date,r)

