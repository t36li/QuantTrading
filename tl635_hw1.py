from datetime import datetime
from pandas.io.data import DataReader
from pandas.io.data import Options
from yahoo_finance import Share

import datetime as dt
import matplotlib.pyplot as plt
import scipy.stats as ss
import time
import numpy as np
import pdb
import csv


def jgb_3graphs():
	""""
	This function calculates the open, close and daily VWAP prices for all the days in
	the JB2014_JST.csv file and graphs the result.

	return: a tuple of lists where the first element is the open prices, second
	is the close prices and the third is vwap prices.

	NOTE: Please do not have the file anywhere other than your current working 
	directory when reading the csv file such that when opening it should be you should only 
	have to call something like open('JB2014_JST.csv') and NOT 
	open('/foldname1/foldname2/user/JB2014_JST.csv'))

	NOTE2: This function may take awhile to run depending on how you implement
	"""
	f = open('JB2014_JST.csv', 'rU')
	csv_f = csv.reader(f)
	next(csv_f) #discards header

	price=[]
	size=[]
	open_price=[]
	close_price=[]
	vwap=[]
	tic=time.clock()
	for row in csv_f:
		#pdb.set_trace()
		date=datetime.strptime(row[2],'%H:%M:%S.%f')
		
		if (dt.time(8, 45) < date.time() < dt.time(15,2)):
			#if current price is within trading hours
			#pdb.set_trace()
			price.append(row[3])
			size.append(row[4])
		else:			
			# compute open, end, vwap and empty price+size lists, then append price+size for new "day"
			if (price and size):
				open_price.append(price[0])
				close_price.append(price[-1]) #last element
				prices=np.array(price,dtype=float)
				sizes=np.array(size,dtype=float)
				vwap.append(np.dot(prices,sizes)/sum(sizes))
				del price[:]
				del size[:]

	#pdb.set_trace()
	toc=time.clock()
	print 'Took ' + str(toc-tic) + ' seconds to read file in Q1'
	x = np.arange(len(open_price)) + 1 
	plt.plot(x, np.array(open_price), 'r--', label='Open')
	plt.plot(x, np.array(close_price),'bs', label='Close')
	plt.plot(x, np.array(vwap),'g^', label='VWAP')
	plt.legend(loc='best', shadow=True)
	plt.show()
	#pdb.set_trace()
	return (open_price,close_price,vwap)

def dayEffect(t1,t2,S,d):
	"""
	param t1: the start date in the format 'yyyy-MM-dd'
	param t2: the end date in the format 'yyyy-MM-dd'
	param S: the stock symbol as can be found on yahoo finance
	param d: the day of the week to preform the backtesting where
	 	0=Monday, 1=Tuesday, ... 4=Friday (5 and 6 are weekends and do not trade)
	 	(notice this is different from what the pdf states)

	return: profit genereated from the trading strategy

	Function calculates the profit generated from buying a stock at open everyday
	between t1 and t2 (inclusive) and sells on the close for day d. Profit generated from such
	a strategy is returned.

	NOTE: please have the day which is the most profitable listed as a comment at the END 
	of this function
	"""
	if d in range(5):
		bars = DataReader(S, "yahoo", datetime.strptime(t1, '%Y-%m-%d'),datetime.strptime(t2,'%Y-%m-%d'))
		#pdb.set_trace()
		
		returns=[]
		profit=0
		for i in range(len(bars.index)):
			#pdb.set_trace()
			if bars.index[i].weekday() == d:
				profit += bars['Close'][i]-bars['Open'][i]
				returns.append((bars['Close'][i]-bars['Open'][i])/bars['Open'][i])

		print 'The average return for the startegy is ' + str(np.mean(returns)) + ' when trading on every ' + str(d) + ' day'
		print 'The profit generated by buying/selling one share on every ' + str(day) + ' is ' + str(profit)
	else:
		print 'Please enter a valid trading day!'
	# By running dayEffect 5 times for Mon - Friday, the day that is most profitable is Wednesday


#Black and Scholes Helper Functions
def d1(S0, K, r, sigma, T):
	return (np.log(S0/K) + (r + sigma**2 / 2) * T)/(sigma * np.sqrt(T))
 
def d2(S0, K, r, sigma, T):
	return (np.log(S0 / K) + (r - sigma**2 / 2) * T) / (sigma * np.sqrt(T))
 
def BlackScholes(type,S0, K, r, sigma, T):
	if type=="C":
		return S0 * ss.norm.cdf(d1(S0, K, r, sigma, T)) - K * np.exp(-r * T) * ss.norm.cdf(d2(S0, K, r, sigma, T))
	else:
		return K * np.exp(-r * T) * ss.norm.cdf(-d2(S0, K, r, sigma, T)) - S0 * ss.norm.cdf(-d1(S0, K, r, sigma, T))

def impliedVolBisection(S,K,T,r,Price,x1,x2,Call=True,d=0,tol=0.0001):
	"""
	param S: the stock price
    param K: the strike price
    param r: the risk free rate
    param T: time to mature of the option (percent of year in decmial form)
    param Price: The price of the option you are trying to find implied vol for
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations
    
    returns: implied vol with above paramaters

    Finds the implied volatility using the above paramters for a option using the 
    bisection method
	"""
	a=x1
	b=x2

	def f(x):
		return BlackScholes('C',S,K,r,x,T) - Price

	c = (a+b)/2.0
	while (b-a)/2.0 > tol:
		if f(c) == 0:
			return c
		elif f(a)*f(c) < 0:
			b = c
		else :
			a = c
		c = (a+b)/2.0
		
	return c

def impliedVolNewton(S,K,T,r,Price,x0,Call=True,d=0,tol=0.0001):
	"""
	param S: the stock price
    param K: the strike price
    param r: the risk free rate
    param T: time to mature of the option (percent of year in decmial form)
    param Price: The price of the option you are trying to find implied vol for
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations
    returns: implied vol with above paramaters

    Finds the implied volatility using the above paramters for a option using 
    newton's method
    """

	def f(x):
		return BlackScholes('C',S,K,r,x,T) - Price

	def df(x,dx):
		return (f(x+dx) - f(x))/dx

	x=x0
	dx=tol
	#tol=0.000001

	while True:
		x1 = x - f(x)/df(x, dx)
		t = abs(x1 - x)
		if t < tol:
			break
		x = x1

	return x

def QuadFit(symbol,strikes,expiry_date,r,Call=True,d=0,tol=.0001):
	"""
	param symbol: stock symbol
	param strikes: list of strikes in increasing order
	param expiry_date: expiry date in format 'yyyy-MM-dd'
	param r: risk free rate
	param Call: optional paramater to inditify put or call
	param d: optional paramter for divident yield
	param tol: tolerance for implied vol calculations

	This function fits a quadratic function to the strikes given and graphs 
	the quadratic function and implied vols on the same graph

	returns: nothing

	NOTE: This function may take awhile to run depending on how you implement.
	In addition please use 365 days when calculating T and live prices (20 minute delay is OK).
	See the module yahoo_finance's Share class for a simply way to do this.
	"""
	tic=time.clock()
	expiry_formatted = datetime.strptime(expiry_date, '%Y-%m-%d')
	data = Options(symbol, 'yahoo').get_call_data(expiry=expiry_formatted)
	toc=time.clock()
	print 'Took ' + str(toc-tic) + ' seconds to load data using pandas'
	

	S = float(Share(symbol).get_price())
	
	T = float((expiry_formatted-datetime.today()).days)/365
	interest = r


	impVols=[]
	tic=time.clock()
	for i in range(len(strikes)):
		#pdb.set_trace()
		K = strikes[i]
		C_price = data.loc[K,:].iloc[0][2] #take option for Strike = K, Ask price
		impVols.append(impliedVolBisection(S,K,T,interest,C_price,-1,1))

	toc=time.clock()
	print 'Took ' + str(toc-tic) + ' seconds to complete all IV calculations'
	x=np.array(strikes)
	y=np.array(impVols)
	z = np.polyfit(x,y,2) #fit a second order polynomial to IV
	p = np.poly1d(z)

	xp = np.linspace(50, 330, 500)
	plt.plot(x, y, '.', xp, p(xp), '-')
	plt.ylim(-1,1)
	plt.show()

if __name__ == '__main__':

	S0 = 100.0 #stock price
	K = 110.0 #strike price
	T = 3.0 #Years
	r = 0.1 #rf rate (decimal)
	c_Price = 37.0 #call price
	x1 = 0.1 #a or x1 for bisection method 
	x2 = 0.5 #b or x2 for bisection method 
	x0 = 0.4 #initial guess for newton's method 
	symbol = 'SPY' #symbol for option
	day = 0  #day for dayEffect 0=Monday 1= Tuesday ... 4= Friday
	strikes = [150,160,170,180,190,195,200,210,220,230] #list of strike prices
	expiry_date = '2015-12-19' #expiry date for option

	#Preform Question 1 Hw1
	jgb_3graphs()

	#Preform Question 2 Hw1
	dayEffect('2014-01-01','2014-12-31',symbol,day)
	
	#Preform Question 3 Hw1
	impliedVolBisection(S0,K,T,r,c_Price,x1,x2)

	#Preform Question 4 Hw1
	impliedVolNewton(S0,K,T,r,c_Price,x0)

	#Preform Question 5 Hw1
	QuadFit(symbol,strikes,expiry_date,r)

